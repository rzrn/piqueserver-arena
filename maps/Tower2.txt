# Copyright © 2024–2025 rzrn

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from itertools import product
from random import Random

from pyspades.common import make_color
from pyspades.vxl import VXLData

from arenalib.maptools import HSV3fAsRGB3i

name    = 'Tower2'
version = '2.1'

extensions = dict(
    water_damage      = 100,
    arena_blue_spawn  = (218, 218, 12),
    arena_green_flag  = (222, 222, 12),
    arena_blue_base   = (256, 252, 0),
    arena_green_spawn = (294, 294, 12),
    arena_green_base  = (256, 260, 0),
    arena_blue_flag   = (290, 290, 12)
)

mask = None

def is_indestructable(connection, x, y, z):
    return mask.get_solid(x, y, z)

def rect(xsize, ysize):
    yield from product(range(-xsize, xsize + 1), range(-ysize, ysize + 1))

def inner(vxl, color, z1, z2, size):
    assert z1 % (2 * size + 1) == 0
    assert z2 % (2 * size + 1) == 0

    rgba = make_color(*color)

    for Δx, Δy in rect(2 * size, 2 * size):
        x, y = 256 + Δx, 256 + Δy

        # columns around the tower
        if max(abs(Δx), abs(Δy)) == 2 * size:
            if (Δx + Δy) % 2 == 0:
                vxl.set_column_fast(x, y, z1, z2, z2, rgba)
                mask.set_column_fast(x, y, z1, z2, 0, 0)

        # walls covering the stairs
        if abs(Δx) <= size and abs(Δy) == size:
            vxl.set_column_fast(x, y, z1, z2, z2, rgba)

        if abs(Δx) <= size and abs(Δy) < size:
            # the stairs
            for z in range(z1 + 1, z2):
                if (z - 1) % (2 * size + 1) == size - Δx:
                    vxl.set_point(x, y, z, color)
        else:
            # floors
            for z in range(z1, z2):
                if z % (2 * size + 1) == 0:
                    vxl.set_point(x, y, z, color)

def annulus():
    for Δx, Δy in rect(64, 64):
        if 32 <= max(abs(Δx), abs(Δy)):
            yield Δx, Δy

def outer(vxl, color, z1, z2):
    rgba = make_color(*color)

    for Δx, Δy in annulus():
        x, y = 256 + Δx, 256 + Δy

        P = max(abs(Δx), abs(Δy)) in {32, 64} # facade
        Q = 36 <= abs(Δx) <= 40 and 36 <= abs(Δy) <= 40 # spawn

        if Δx % 4 == 0 and Δy % 4 == 0:
            vxl.set_column_fast(x, y, z1, z2, z2, rgba)

            if P: mask.set_column_fast(x, y, z1, z2, 0, 0)
            if Q: mask.set_column_fast(x, y, z1 + 8, z2, 0, 0)

        # floors
        for z in range(z1, z2 + 1):
            if z % 8 == z1 % 8:
                vxl.set_point(x, y, z, color)

        if Q: mask.set_point(x, y, z1 + 8, (0, 0, 0))

def gen_script(basename, seed):
    global fog

    rgen = Random(seed)

    hue = rgen.uniform(0.0, 1.0)

    water  = HSV3fAsRGB3i(hue, rgen.uniform(0.3, 0.4), 1.0)
    fog    = HSV3fAsRGB3i(hue, rgen.uniform(0.2, 0.3), 1.0)
    color1 = HSV3fAsRGB3i(hue, rgen.uniform(0.2, 0.3), 1.0)
    color2 = HSV3fAsRGB3i(hue, rgen.uniform(0.2, 0.3), 1.0)

    vxl = VXLData()

    global mask
    mask = VXLData()

    for x, y in product(range(512), range(512)):
        vxl.set_point(x, y, 63, water)

    inner(vxl, color2, z1 = 0, z2 = 63, size = 3)
    outer(vxl, color1, z1 = 4, z2 = 63)

    return vxl
